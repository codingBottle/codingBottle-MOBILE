# 김하은 질문

### Class (클래스)

- **기본 개념**
    - 클래스는 **참조(reference) 타입**
    - 인스턴스는 참조되며, 여러 변수가 동일한 인스턴스를 가리킬 수 있음
- **선언 조건**:
    - **`class`** 키워드를 사용하여 선언
    - `**프로퍼티와 메서드**`를 가질 수 있으며, 추가로 클래스 상속이 가능
    - **`초기화(Initializer)`**를 직접 구현해야 함
    - `**참조 카운팅(reference counting)**`을 통해 메모리 관리가 이루어짐

```swift
class Person {
    var name: String
    var age: Int
    
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}
```

- **객체와 인스턴스**
    - **객체(Object)**: "객체"라는 용어는 일반적으로 소프트웨어에서 실제로 존재하는 모든 것을 가리킵니다. 이것은 개념적인 것일 수도, 실제로 물리적으로 존재할 수도 있습니다. 예를 들어, 자동차, 고양이, 사용자 등 모든 것이 객체입니다.
    - **인스턴스(Instance)**: "인스턴스"는 클래스(템플릿)를 기반으로 생성된 구체적인 실체를 의미합니다. 클래스를 설계도로 생각하면, 그 클래스를 사용하여 만든 실제 물건이 인스턴스입니다. 예를 들어, **`Person`** 클래스로부터 생성된 실제 사람 객체(인스턴스)를 생각할 수 있습니다.
    - **정리** : 클래스로부터 만들어진 객체를 인스턴스라고 한다. 클래스로 부터 객체를 만든다 → 실제로 만들어져 메모리에 올려져 있는 객체가 인스턴스이다.
    - **예시 코드**
    
    ```swift
    // 클래스 정의
    class Person {
        var name: String
        var age: Int
        
        init(name: String, age: Int) {
            self.name = name
            self.age = age
        }
    }
    
    // 인스턴스 생성
    let personInstance = Person(name: "John", age: 30)
    ```
    
- **초기화**
    - 초기화란 변수나 상수의 초기값을 정해주는 것
- **프로퍼티와 메서드**
    - **프로퍼티(Property)**: 프로퍼티는 클래스나 구조체 내부에 저장된 값 또는 데이터를 나타냅니다. 예를 들어, **`Person`** 클래스에서 **`name`**과 **`age`**는 프로퍼티입니다.
    - **메서드(Method)**: 메서드는 클래스나 구조체 내부에서 수행되는 동작 또는 함수입니다. 예를 들어, **`Person`** 클래스에서 **`init`** 메서드는 객체를 초기화하는 역할을 합니다.
    - 예시 코드
    
    ```swift
    class Person {
        var name: String  // 프로퍼티
        var age: Int     // 프로퍼티
        
        init(name: String, age: Int) { // 메서드
            self.name = name
            self.age = age
        }
        
        func sayHello() { // 메서드
            print("안녕하세요, 저는 \(name)이고 \(age)살입니다.")
        }
    }
    
    let personInstance = Person(name: "Alice", age: 25)
    personInstance.sayHello() // "안녕하세요, 저는 Alice이고 25살입니다." 출력
    ```
    
- **참조 카운팅**
    
    **참조 카운팅**은 메모리 관리 기술로, 객체(클래스 인스턴스)가 참조되는 횟수를 추적하여 메모리에서 제거되지 않도록 하는 것을 의미합니다. 
    
    쉽게 말하면, 객체가 몇 번 참조 되는지 세어서 참조가 없을 때 메모리에서 자동으로 해제됩니다.
    
    ```swift
    class Person {
        var name: String
        
        init(name: String) {
            self.name = name
        }
    }
    
    var person1: Person? = Person(name: "John") // 참조 카운트: 1
    var person2: Person? = person1 // 참조 카운트: 2
    var person3: Person? = person1 // 참조 카운트: 3
    
    person1 = nil // 참조 카운트: 2
    person2 = nil // 참조 카운트: 1
    person3 = nil // 참조 카운트: 0, 메모리에서 자동 해제
    ```
    

### **Struct (구조체)**

- **기본 개념**
    - 구조체는 **값(value) 타입**
    - 이것은 인스턴스가 복사될 때 데이터가 복사되며 참조가 아닌 값을 저장합니다.
- **선언 조건**:
    - **`struct`** 키워드를 사용하여 선언함
    - `**프로퍼티(멤버 변수)**`와 **`메서드(멤버 함수)`**를 가질 수 있음
    - **`기본 초기화(Initializer)`**가 자동으로 생성됨
    - 상속은 지원하지 않음
    - **`불변성(Immutability)`** 측면에서 구조체의 프로퍼티를 상수로 선언하면 해당 프로퍼티는 불변(immutable)이 되어 값을 변경할 수 없음
- **예시:**
    
    ```swift
    struct Point {
        var x: Double
        var y: Double
    }
    ```
    
- **프로퍼티와 메서드**
    - **`name`**과 **`age`**라는 두 개의 프로퍼티를 가지고 있음.
    - **`sayHello`**라는 메서드를 가지고 있음.
    - 이를 통해 구조체는 데이터를 저장하고, 해당 데이터에 대해 동작을 수행하는 데 사용됩니다. 이러한 방식으로 구조체는 간단한 객체나 데이터를 모델링하는 데 유용합니다.
    - 예시 코드
    
    ```swift
    struct Person {
        var name: String // 이름을 저장하는 프로퍼티
        var age: Int    // 나이를 저장하는 프로퍼티
        
        // 인사말을 출력하는 메서드
        func sayHello() {
            print("안녕하세요, 제 이름은 \(name)이고, \(age)살입니다.")
        }
    }
    
    // Person 구조체의 인스턴스 생성
    let personInstance = Person(name: "Alice", age: 25)
    
    // 프로퍼티에 접근하여 값을 가져오고 출력
    let personName = personInstance.name // "Alice"
    let personAge = personInstance.age    // 25
    
    // 메서드 호출하여 인사말 출력
    personInstance.sayHello() // "안녕하세요, 제 이름은 Alice이고, 25살입니다." 출력
    ```
    
- **초기화**
    - 초기화란 변수나 상수의 초기값을 정해주는 것
    - **`Person`** 구조체를 사용하여 **`personInstance`**라는 인스턴스를 생성할 때 별도의 초기화 과정이 없어도 됨. 이는 기본 초기화가 자동으로 제공되고, 모든 프로퍼티에는 기본값이 설정되어 있기 때문임.
    
    ```swift
    struct Person {
        var name: String = "Unknown"
        var age: Int = 0
    }
    
    // 기본 초기화를 사용하여 Person 구조체의 인스턴스 생성
    let personInstance = Person()
    
    print(personInstance.name) // "Unknown" 출력
    print(personInstance.age)  // 0 출력
    ```
    
    그러면 .. 초기화를 사용자가 직접 생성해줘도 될까?
    
    → 초기화를 사용자가 직접 생성할 수 있다. **구조체가 만들어주는 초기화말고 유연하게(내가 원하는 대로) 초기화가 필요할 때 한다!**
    

### **Enum (열거형)**

- **기본 개념**
    - 열거형은 **유한한 값의 집합**을 나타냄
    - 주로 연관된 값들을 그룹화하거나 명명할 때 사용됩니다.
- **선언 조건**:
    - **`enum`** 키워드를 사용하여 선언
    - **`케이스(case)를 정의`**하며, 각 케이스는 연관 값을 가질 수 있음
    - 메서드를 추가할 수 있으며, 연관 값에 따라 다른 동작을 구현할 수 있음
- 예시 :

```swift
enum CompassDirection {
    case north
    case south
    case east
    case west
}
```

- **케이스를 정의**
    
    ```swift
    // 각 케이스는 연관 값을 가질 수 있는 열거형 정의
    enum Device {
        case homeScreen
        case settings
        case camera
    }
    
    // Device 열거형의 인스턴스 생성
    let currentDevice = Device.homeScreen
    
    // 각 케이스에 연관된 값을 확인하고 출력
    switch currentDevice {
    case .homeScreen:
        print("현재 홈 화면입니다.")
    case .settings:
        print("현재 설정 화면입니다.")
    case .camera:
        print("현재 카메라 앱입니다.")
    }
    ```
    
     **`Device`**라는 열거형을 정의
    
    이 열거형은 기기의 이름을 나타내는 케이스를 세 가지로 정의하고 있음. (**`homeScreen`**, **`settings`**, **`camera`**) → 중요한 점은 각 케이스가 연관 값을 가질 수 있다는 것임.
    
    정리하면 … 마치 장난감 상자 안에 다양한 종류의 장난감들이 들어있고, 각 장난감은 다른 속성을 가지고 있는 것과 비슷하다고 생각할 수 있음.
    
    여기서 "장난감 상자"가 열거형이며, 각 장난감이 열거형의 케이스이며, 각 장난감이 다른 특징을 가질 수 있는 것과 같음.
    

## struct와 class와 enum의 차이를 설명하시오.

- 구조체는 값을 복사하여 독립적인 인스턴스를 생성하고, 클래스는 참조를 통해 같은 인스턴스를 공유하며, 열거형은 연관된 값을 그룹화하는 데 사용된다.
    - struct (값타입) : 복사할 때 새로운 데이터가 하나 더 생김.
    - enum (값타입) : 연관된 값을 그룹화하는 데 사용됨.
    - class (참조타입) : 복사할 때 주소를 복사해 한 데이터의 reference가 2개 생김.

- 구조체는 주로 간단한 데이터 형식을 나타내는 데 사용되고, 클래스는 복잡한 객체와 상속을 다루는 데 사용되며, 열거형은 연관된 값의 집합을 표현하는 데 유용합니다.

## 값 vs 참조의 차이점

- **값 타입 vs 참조 타입**
    - **class** : 클래스는 참조(reference) 타입으로, 여러 변수가 동일한 인스턴스를 가리킬 수 있습니다. 따라서 한 변수에서 변경된 내용이 다른 변수에도 영향을 미칩니다.
    - **struct & enum** : 구조체와 열거형은 값(value) 타입으로, 각각의 인스턴스가 별도의 공간에 저장되며 독립적으로 작동합니다. 한 변수에서 변경된 내용이 다른 변수에 영향을 주지 않습니다.
- **상속**
    - **class** : 클래스는 상속(inheritance)을 지원하며, 부모 클래스의 특성과 동작을 자식 클래스로 확장할 수 있습니다. 이는 코드 재사용을 가능하게 함.
    - **struct & enum** : 구조체와 열거형은 상속을 지원하지 않음. 따라서 상속 계층 구조를 생성할 수 없음.
- **참조 카운팅**
    - **class** : 클래스는 참조(reference) 타입이므로 참조 카운팅(reference counting)을 통해 메모리 관리가 이루어집니다. 여러 변수가 동일한 인스턴스를 참조할 수 있고, 참조가 없을 때 메모리에서 자동으로 해제됩니다.
    - **struct & enum** : 구조체와 열거형은 값(value) 타입으로, 참조 카운팅을 사용하지 않으며 인스턴스를 복사하여 사용합니다. 이로 인해 메모리 관리에 대한 별도의 걱정이 필요하지 않습니다.
- **뮤텍스(Mutex)와 동기화(Synchronization)** → 멀티스레드 환경에서 발생할 수 있는 문제를 해결하기 위한 개념
    - **class** : 클래스는 멀티스레드 환경에서 데이터를 공유하고 동기화하기 위해 사용됩니다. 뮤텍스와 같은 동기화 메커니즘을 사용하여 데이터의 안전한 공유를 보장할 수 있습니다.
    - **struct & enum**: 구조체와 열거형은 주로 불변 데이터를 표현하는 데 사용되며, 데이터를 공유하는 경우 동기화의 필요성이 낮을 수 있습니다.
    - **뮤텍스와 동기화 개념**
        1. **뮤텍스(Mutex)**:
            - **뮤텍스**는 Mutual Exclusion(상호 배제)의 줄임말로, 여러 스레드가 공유 자원(데이터, 자료구조 등)에 동시에 접근하지 못하도록 제한하는 도구나 메커니즘을 가리킵니다.
            - 뮤텍스는 보통 임계 영역(critical section)으로 불리는 코드 영역을 보호하는 데 사용됩니다. 임계 영역은 여러 스레드가 동시에 접근하면 문제가 발생할 수 있는 곳으로, 뮤텍스를 사용하면 한 번에 하나의 스레드만 임계 영역에 진입할 수 있도록 보장합니다.
        2. **동기화(Synchronization)**:
            - **동기화**는 여러 스레드 간에 작업의 실행을 조절하고, 스레드 간의 데이터 공유를 조절하여 예측 가능하고 안정적인 프로그램 실행을 보장하는 것을 의미합니다.
            - 동기화는 스레드 간의 경쟁 상태(race condition)와 같은 문제를 방지하고, 데이터 일관성을 유지하기 위해 사용됩니다. 이를 통해 여러 스레드가 협력하여 작업을 수행하더라도 문제없이 동작할 수 있습니다.
        
        간단한 예로, 뮤텍스와 동기화를 사용하여 여러 스레드가 공유 자원에 안전하게 접근하고 변경할 수 있도록 보장할 수 있습니다. 이를 통해 데이터 손실, 경쟁 상태, 데드락 등의 문제를 피하고 안정성을 확보할 수 있습니다.
        
    

한 변수에서 변경된 내용이 다른 변수에 영향을 주는 지에 따라 다르게 됩니다.

클래스는 참조타입으로 여러 변수가 동일한 인스턴스를 가리킬 수 있어 한 변수에서 변경된 내용이 다른 변수에도 영향을 미칩니다. 

구조체와 열거형은 값(value) 타입으로, 각각의 인스턴스가 별도의 공간에 저장되며 독립적으로 작동해 한 변수에서 변경된 내용이 다른 변수에 영향을 주지 않습니다.

상속

복사

## 값 타입 내 차이점

1. **구조체(struct)**:
    - **사용 시점**: 구조체는 주로 데이터의 불변성(immutability)과 간단한 값의 저장에 사용됩니다. 데이터의 변경이 필요 없는 경우나, 복사가 빠른 경우에 구조체를 사용합니다.
    - **예시 시나리오**: 좌표, 벡터, 날짜, 시간, 색상 등의 단순한 데이터 구조를 표현할 때 유용합니다.
    - **장점**: 복사가 빠르고 값의 불변성을 통해 예상치 못한 부작용을 방지합니다. 멀티스레드 환경에서 안전합니다.
2. **열거형(enum)**:
    - **사용 시점**: 열거형은 연관된 값을 그룹화하거나 제한된 선택지를 표현할 때 사용됩니다. 주로 명명된 상태(State)나 옵션(Option)을 나타내기 위해 사용됩니다.
    - **예시 시나리오**: 주사위 눈금, 요일, 주문 상태(처리 중, 완료, 취소) 등을 표현할 때 유용합니다.
    - **장점**: 명확한 선택지를 가질 때 코드 가독성을 향상시킵니다. 스위프트에서 패턴 매칭(pattern matching)과 함께 강력한 기능을 제공합니다.

### **사용 사례 선택**:

- 구조체는 `단순한 데이터 컨테이너` 또는 `값의 불변성이 중요한 경우`에 사용합니다.
- 열거형은 `연관된 값을 그룹화`하거나 `제한된 선택지`를 나타내는 경우에 사용합니다.
- 구조체는 `단순한 데이터 컨테이너` 또는 `값의 불변성이 중요한 경우`에 사용합니다.
- 열거형은 `연관된 값을 그룹화`하거나 `제한된 선택지`를 나타내는 경우에 사용합니다.

## class의 성능을 향상 시킬수 있는 방법들을 나열해보시오.

### 성능을 향상 시킬 수 있는 방법들

1. **레퍼런스 카운팅 최적화**
    - 클래스는 참조(reference) 타입으로, 참조 카운팅(reference counting)을 사용하여 메모리 관리가 이루어집니다. 불필요한 참조 카운팅 작업을 최소화하기 위해 참조 순환(reference cycles)을 피하고 **`weak`** 참조를 사용하여 강한 참조 순환을 방지합니다.
2. **지연된 초기화(Lazy Initialization)**
    - 객체의 프로퍼티 중에서 초기화가 느린 프로퍼티는 지연 초기화를 사용하여 필요한 시점에 초기화를 수행하도록 할 수 있습니다. 이렇게 하면 초기화 시간을 분산시켜 성능을 향상시킬 수 있습니다.
3. **성능 최적화된 컬렉션 사용**
    - 배열(Array), 딕셔너리(Dictionary), 세트(Set) 등과 같은 컬렉션을 사용할 때 성능을 고려하여 적절한 데이터 구조를 선택합니다. 필요한 검색, 삽입, 삭제 작업에 따라서 최적의 컬렉션을 사용합니다.
4. **비동기 프로그래밍(Asynchronous Programming)**
    - 비동기 작업을 사용하여 CPU 및 I/O 작업의 병렬 처리를 통해 성능을 향상시킬 수 있습니다. Grand Central Dispatch(GCD)와 같은 도구를 사용하여 비동기 작업을 구현합니다.
5. **메모리 관리 최적화**
    - 메모리 관리를 최적화하여 불필요한 메모리 사용을 줄이고 메모리 누수(memory leaks)를 방지합니다. 약한 참조(weak reference), 비소유 참조(unowned reference)를 사용하여 메모리를 안전하게 관리합니다.
6. **프로파일링(Profiling) 및 최적화**
    - Xcode와 같은 개발 도구를 사용하여 애플리케이션을 프로파일링하고 성능 병목 현상을 식별합니다. 성능을 저하시키는 부분을 최적화하고 반복적으로 성능 테스트를 수행합니다.
7. **코딩 최적화**
    - 효율적인 알고리즘 및 자료구조를 선택하고, 루프와 반복문을 최적화하며, 불필요한 객체 생성을 피하고 복잡한 연산을 최적화합니다.
8. **UI 스레드와 백그라운드 스레드 분리**
    - UI 스레드와 백그라운드 스레드를 분리하여 UI 작업이 끝나기를 기다리지 않고 백그라운드에서 작업을 수행하도록 구현합니다. 이는 앱의 반응성을 향상시킬 수 있습니다.
9. **캐시 사용**
    - 빈번하게 사용되는 데이터나 연산 결과를 캐시에 저장하여 중복 계산을 피하고 성능을 향상시킵니다.
10. **인스턴스 풀링(Instance Pooling)**
    - 객체 생성 및 해제 비용이 높을 때, 객체를 미리 생성해 두고 재사용하여 성능을 향상시킵니다.

**지연된 초기화(Lazy Initialization)**

- 객체의 프로퍼티 중에서 초기화가 느린 프로퍼티는 지연 초기화를 사용하여 필요한 시점에 초기화를 수행하도록 할 수 있습니다. 이렇게 하면 **초기화 시간을 분산**시켜 성능을 향상시킬 수 있습니다.

**UI 스레드와 백그라운드 스레드 분리**

- UI 스레드와 백그라운드 스레드를 분리하여 UI 작업이 끝나기를 기다리지 않고 백그라운드에서 작업을 수행하도록 구현합니다. 이는 앱의 반응성을 향상시킬 수 있습니다.

## Struct 가 무엇이고 어떻게 사용하는지 설명하시오.

Struct는 값 타입(Value Type)으로 **데이터와 관련된 값을 묶어서 표현하는데 사용**됩니다. 

- **구조체를 사용하는 주요 목적**
    1. **데이터 불변성**: 구조체 내부의 속성(프로퍼티)은 일반적으로 **상수(let)로 선언되어 변경할 수 없게끔 설계**됩니다. (이로써 데이터의 불변성을 보장하고) **예기치 않은 변경을 방지**합니다.
    2. **값 타입**: 구조체는 값 타입(Value Type)이기 때문에 값을 복사하여 독립적인 인스턴스를 생성하며, **한 인스턴스의 변경이 다른 인스턴스에 영향을 미치지 않습니다.**
    3. **코드 재사용**: 구조체는 프로퍼티와 메서드를 포함할 수 있으므로 코드를 재사용하고 모듈화할 수 있습니다.
    4. **데이터 그룹화**: 관련된 데이터를 하나의 그룹으로 묶어서 표현할 때 사용합니다. 예를 들어, 사용자 정보를 저장하는 구조체를 정의하여 이름, 나이, 주소 등을 함께 관리할 수 있습니다.
- **구조체를 어떻게 사용하는지**
    1. **데이터 모델링**: Struct를 사용하여 데이터를 모델링하고 저장할 수 있습니다. 예를 들어, 사용자 정보, 제품 정보, 지리적 위치 정보 등을 담는 데 사용할 수 있습니다.
    2. **불변성 데이터**: Struct는 내부의 프로퍼티를 상수(**`let`**)로 선언하여 불변성 데이터 구조를 만들 수 있습니다. 이는 데이터의 안정성과 예측 가능한 동작을 제공합니다.
    3. **메서드와 기능 추가**: Struct 내부에 메서드를 추가하여 특정 작업을 수행하는 기능을 구현할 수 있습니다.
    4. **값 복사**: Struct는 값 타입이므로 인스턴스를 복사하여 독립적인 데이터를 생성할 수 있습니다. 이는 다른 인스턴스에 영향을 미치지 않습니다.
    5. **옵셔널 타입 초기화**: Struct를 사용하여 옵셔널 타입을 초기화하고 다룰 수 있습니다.
    6. **프로토콜 채택**: Struct는 프로토콜을 채택하여 공통의 인터페이스를 구현할 수 있습니다. 이는 코드 재사용과 다형성을 제공합니다.

### 🧐궁금해용!

- 클래스를 사용하는게 더 편해보이는데 구조체를 사용하는 이유 / 사용하는 때는?
    - 간단한 데이터 값을 한데 묶어서 사용하는 경우
    - 전체 덩어리 크기가 작은 경우, 복사를 통해 전달해도 좋은 경우
    - 멀티쓰레드 환경이면 struct가 더 안전함
    - 상속할 필요가 없는 경우
        - 너비, 높이를 표현하는 기하학적 모양을 처리하는 경우
        - 순영을 표현하는 경우
        - 3차원 좌표 시스템의 각 좌표

# 박신영 질문

## class 메서드와 static 메서드의 차이점을 설명하시오.

### swift의 메서드

- **instance method** : 인스턴스 메서드는 "인스턴스"와 연관된 메서드이기 때문에, "인스턴스를 생성해야만" 해당 인스턴스를 통해 메서드에 접근할 수 있으며, 아무런 수식어 없이 func으로 선언된 메서드는 모두 인스턴스 메서드이다
- **Type Method** : static 메서드, class 메서드

## **차이점 정리**

- **클래스와의 관계**
    - 정적 메서드는 **클래스와 무관**하며, 재정의되지 않고 상속되지 않으므로 **항상 동일한 동작**을 합니다.
    - 클래스 메서드는 **클래스에 속하며 상속 및 재정의가 가능**하고, **서브클래스에서 다르게 동작할 수** 있습니다.
        - 서브 클래스마다 다른 구현을 제공하는 예시
            
            ```swift
            // 슈퍼클래스: 동물을 나타내는 Animal 클래스
            class Animal {
                var name: String
                
                init(name: String) {
                    self.name = name
                }
                
                func speak() {
                    print("\(name)은 소리를 낸다.")
                }
            }
            
            // 서브클래스 1: 개를 나타내는 Dog 클래스
            class Dog: Animal {
                override func speak() {
                    print("\(name)은 멍멍하고 짖는다.")
                }
            }
            
            // 서브클래스 2: 고양이를 나타내는 Cat 클래스
            class Cat: Animal {
                override func speak() {
                    print("\(name)은 야옹하고 운다.")
                }
            }
            
            // 서브클래스 3: 오리를 나타내는 Duck 클래스
            class Duck: Animal {
                override func speak() {
                    print("\(name)은 꽥꽥거린다.")
                }
            }
            
            // 인스턴스 생성 및 메서드 호출
            let myDog = Dog(name: "멍멍이")
            let myCat = Cat(name: "야옹이")
            let myDuck = Duck(name: "꽥꽥이")
            
            myDog.speak()  // "멍멍이은 멍멍하고 짖는다." 출력
            myCat.speak()  // "야옹이은 야옹하고 운다." 출력
            myDuck.speak() // "꽥꽥이은 꽥꽥거린다." 출력
            ```
            
- **다형성**
    - 클래스 메서드는 객체의 실제 타입에 따라 동적으로 메서드가 호출되는 다형성을 지원합니다.
    - 정적 메서드는 컴파일 타임에 정해진 메서드가 항상 호출되기 때문에 다형성을 지원하지 않습니다.
- `**self` 키워드를 사용해 참조되는 곳이 다르다.**
    - 클래스 메서드 내에서 **`self`** 키워드를 사용하면 현재 클래스 타입을 참조합니다. 
    이는 서브클래스에서 메서드를 재정의할 때 서브클래스 타입으로 자동으로 참조됩니다.
    - 정적 메서드 내에서 **`self`** 키워드는 메서드가 정의된 타입 자체를 가리킵니다. 
    서브클래스에서 재정의하더라도 서브클래스 타입이 아닌 슈퍼클래스 타입으로 참조됩니다.
- **프로퍼티(Property) 및 인스턴스 변수 접근**
    - 프로퍼티와 인스턴스 변수란?
        - **프로퍼티(Property)**: 클래스나 구조체 내부에서 값을 저장하거나 계산한 값을 반환하는 것을 의미합니다. 프로퍼티는 클래스 내부에서 정의되며, 객체의 속성을 표현합니다.
        - **인스턴스 변수(Instance Variable)**: 객체(instance)가 생성될 때마다 해당 객체에 속하는 변수를 의미합니다. 객체마다 고유한 값을 저장할 수 있으며, 객체의 상태를 나타냅니다.
    - **구조체(struct)와 클래스(class)에서의 `static` 메서드의 용도**
        1. **구조체에서의 `static` 메서드**
            - 해당 구조체 자체에 속한 메서드를 정의할 때 사용됩니다.
            - 인스턴스와 관련이 없으며, 구조체의 타입 자체와 관련된 작업을 수행합니다.
            - 구조체의 정적 프로퍼티(static property)와 다른 정적 멤버(static members)에 접근할 수 있습니다.
            
            ```swift
            struct MyStruct {
                static var staticProperty = 0 // 구조체의 정적 프로퍼티
            
                static func staticMethod() {
                    // 정적 메서드 내에서 staticProperty에 접근 가능
                    staticProperty = 10
                }
            }
            ```
            
        2. **클래스에서의 `static` 메서드**
            - 해당 클래스 자체에 속한 메서드를 정의할 때 사용됩니다.
            - 인스턴스와 관련이 없으며, 클래스의 타입 자체와 관련된 작업을 수행합니다.
            - 클래스의 정적 프로퍼티(static property)와 다른 정적 멤버(static members)에 접근할 수 있으며, 클래스 메서드(class method) 또한 정의할 수 있습니다.
            
            ```swift
            class Sodeul {
                let name = "Sodeul"
                static let alias = "SodeulSodeul" // 클래스의 정적 프로퍼티
            
                static func sayHello() {
                    // 정적 메서드 내에서 alias에 접근 가능
                    print(alias)
                }
            
                class func classMethod() {
                    // 클래스 메서드 내에서는 name에 접근 불가능 (에러)
                    // name = "NewName"
                }
            }
            ```
            
            - 클래스 메서드(class method) 내에서 인스턴스 프로퍼티(instance property)에 접근하려면, 클래스 메서드가 호출될 때 해당 프로퍼티에 접근할 인스턴스를 전달해야 합니다. 
            
            클래스 메서드는 특정 인스턴스에 종속되지 않으므로, 인스턴스를 생성하고 해당 인스턴스를 통해 프로퍼티에 접근해야 합니다.
            
            클래스 메서드 내에서 인스턴스 프로퍼티를 변경하는 것은 해당 인스턴스에만 영향을 미치며, 다른 인스턴스에는 영향을 주지 않습니다.
            
            ```swift
            // 클래스 메서드 내에서 name에 접근하려면 ...
            class Sodeul {
                let name = "Sodeul"
                static let alias = "SodeulSodeul" // 클래스의 정적 프로퍼티
            
                class func classMethod() {
                    // 클래스 메서드에서 name에 접근하려면 인스턴스를 생성해야 함
                    let sodeulInstance = Sodeul()
                    sodeulInstance.name = "NewName"
                    print(sodeulInstance.name) // "NewName"
                }
            }
            
            // 클래스 메서드 호출
            Sodeul.classMethod()
            ```
            
    
    ```swift
    // 구조체에서의 static
    struct MyStruct {
        let name = "Sodeul"               
        static let alias = "SodeulSodeul"
        
            func sayHello() {
            print(name)            
            print(Sodeul.alias) // 정적 프로퍼티는 타입 이름을 통해 접근
        }
    
        class func classMethod() {
            // 에러 코드
                    print(name)
                    // 정답 코드
                    let instance = MyStruct()
            print(instance.name) // 인스턴스를 생성하여 인스턴스 프로퍼티에 접근
                    
                    print(alias)
        }
    
        static func sayHello() {
            print(name)    // 에러: 정적 메서드에서는 인스턴스 프로퍼티에 직접 접근할 수 없음
                    print(alias)   // 정적 메서드 내에서는 정적 프로퍼티에 직접 접근 가능
        }
    }
    
    // 클래스에서의 static
    class Sodeul {
        let name = "Sodeul"               
        static let alias = "SodeulSodeul"  
     
            func sayHello() {
            print(name)            
            print(Sodeul.alias)    // 정적 프로퍼티는 타입 이름을 통해서 접근
        }
    
            class func classMethod() {
                    // 에러 코드
                    print(name)    
                    print(alias)
                    // 정답 코드
                    print(Sodeul.name) // 클래스 타입 이름을 통해 접근
            print(Sodeul.alias) // 클래스 타입 이름을 통해 접근
        }
    
        static func sayHello() {
            print(name)   // 에러: 정적 메서드에서 정적 프로퍼티에 접근 불가
                    print(alias)  // 같은 타입에 한해 타입 이름 없이도 접근 가능
        }
    }
    ```
    

## defer란 무엇인지 설명하시오.

→ **함수 내에서 작성 위치와 상관 없이 함수 종료 직전에 맨 마지막으로 실행되는 구문**

- **언제 사용하나요?**
    - 함수나 메서드의 실행이 끝난 후 정리 작업을 수행할 때.
    - 파일을 열고 나서 항상 파일을 닫아야 하는 경우.
    - 자원을 할당하고 사용한 후 항상 자원을 해제해야 하는 경우 (예: 메모리 관리)
- **`defer` 블록 내에서 변수와 상수를 사용할 수 있나요?**
    - 네, **`defer`** 블록이 현재 스코프 내에서 실행되기 때문에 **`defer`** 블록 내에서 현재 스코프의 변수와 상수에 접근할 수 있습니다.
    - 다만, **`defer`** 블록 내에서 변수나 상수를 수정하는 것은 불가능합니다.
     **`defer`** 블록은 주로 정리 작업을 수행하거나 값을 출력하는 데 사용됩니다.
- **왜 사용하나요?**
    - 리소스 정리
        - 파일을 열었을 때, 메모리를 할당했을 때, 네트워크 연결을 설정했을 때 등의 상황에서 **`defer`**를 사용하여 해당 리소스를 항상 정리하도록 보장할 수 있습니다. 이를 통해 리소스 누수를 방지할 수 있습니다.
    - 트랜잭션 처리
        - 데이터베이스 작업 또는 파일 작업과 같은 트랜잭션을 처리할 때, 트랜잭션 시작 시점과 종료 시점에 **`defer`**를 사용하여 롤백 또는 커밋을 보장할 수 있습니다.
    - 자원 해제
        - 메모리나 다른 자원을 할당한 경우, **`defer`**를 사용하여 해당 자원을 해제할 수 있습니다. 이를 통해 메모리 누수를 방지하고 리소스를 효율적으로 관리할 수 있습니다.
    - 설정 초기화 및 정리
        - 객체나 클래스의 초기화 과정 또는 설정 초기화 및 정리에 사용될 수 있습니다. **`init`** 메서드나 클래스 초기화 시 **`defer`**를 사용하여 설정 초기화 및 정리 코드를 작성할 수 있습니다.
        - 이점
            1. **가독성 향상**: **`init`** 메서드 내부에 설정 초기화 및 정리 코드를 직접 작성하는 대신 **`defer`**를 사용하면 초기화 과정과 관련된 코드 블록을 명확하게 분리할 수 있습니다. 이렇게 하면 초기화 코드와 정리 코드가 분리되어 가독성이 향상됩니다.
            2. **중복 코드 제거**: 초기화 및 정리 코드를 여러 곳에서 사용해야 할 때 **`defer`**를 사용하면 중복 코드를 제거할 수 있습니다. 예를 들어, 여러 **`init`** 메서드에서 동일한 정리 코드를 사용해야 할 경우, **`defer`**를 사용하여 중복을 제거할 수 있습니다.
            3. **안전성 향상**: **`defer`**를 사용하면 초기화 중 발생할 수 있는 예외 상황이나 에러에 대한 대비가 강화됩니다. 설정 초기화 및 정리 코드가 분리되어 있기 때문에 정리 코드는 항상 실행되므로 자원 누수를 방지하고 안전한 초기화를 보장합니다.
            4. **유지 보수성 향상**: 코드를 유지 관리할 때 초기화 및 정리 코드를 수정해야 할 경우, 해당 코드를 한 곳에서 수정하면 됩니다. 이는 코드 변경에 대한 유지 보수성을 향상시킵니다.
            5. **확장성**: 클래스에 새로운 초기화 로직이 추가될 때, **`defer`** 블록을 추가하기만 하면 됩니다. 이렇게 하면 초기화 및 정리 코드를 쉽게 확장할 수 있습니다.

**`defer`**를 사용하면 코드의 가독성을 향상시키고, 중요한 작업의 누락을 방지할 수 있습니다. 

또한, 코드의 안정성과 유지 보수성을 높이는 데 도움이 됩니다.

`**defer**`의 대체제란?

## defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.

**`defer` 블록은 코드 내에서 여러 번 사용될 수 있으며, 나중에 작성된 `defer` 블록이 먼저 실행됩니다.** 

**`defer`**가 호출되지 않는 경우

- **`defer`** 블록이 실행되는 스코프 내에서 오류가 발생할 때입니다.
    - 예를 들어, **`defer`** 블록이 포함된 함수가 실행 중에 크래시 되거나 프로그램이 강제 종료되는 경우 **`defer`** 블록은 실행되지 않습니다.
