## 메모리 관리를 위해 

## ARC 를 이용해 

## 메모리 해제를 관리한다고 

## 돼있는데 ARC가 무엇인가?

## 강한 순환 참조의 방지를 위해 

## 사용하는 weak, unowned 

## 참조는 무엇인가?

## struct는 stack에

## class 는 heap에 저장되는데

## 둘 모두로 구현이 가능할 경우

## struct로 구현을 하는게 효율적인가?
## 클래스(class), 구조체(structure), 열거형(enum)은 Swift에서 데이터를 정의하고 다루는 세 가지 주요 타입입니다. 각각의 특징과 차이점은 다음과 같습니다:

 1. 클래스(Class):
   - 클래스는 참조 타입(Reference Type)입니다. 따라서 인스턴스를 생성하고 변수나 상수에 할당할 때는 참조를 전달합니다.
   - 상속을 지원하며, 다른 클래스를 기반으로 새로운 클래스를 정의할 수 있습니다.
   - 클래스 인스턴스는 여러 곳에서 공유될 수 있으며, 메모리 관리를 위해 ARC (Automatic Reference Counting)을 사용하여 메모리 해제를 관리합니다.

2. 구조체(Structure):
   - 구조체는 값 타입(Value Type)입니다. 따라서 인스턴스를 생성하고 변수나 상수에 할당할 때는 값을 복사합니다.
   - 상속을 지원하지 않으며, 단순한 데이터 구조를 나타낼 때 주로 사용됩니다.
   - 구조체 인스턴스는 스택 메모리에 저장되며, 복사에 의한 값 전달이 일어나기 때문에 메모리 관리에 대한 복잡한 작업이 필요하지 않습니다.

3. 열거형(Enum):
   - 열거형은 주로 연관된 값을 그룹화하고 명명한 상수값을 정의하는데 사용됩니다.
   - 각 case는 고유한 값과 연결되며, 연관된 데이터를 가질 수 있습니다.
   - 패턴 매칭(Pattern Matching)과 함께 사용되어 다양한 상태를 표현하고 처리할 때 유용합니다.
   - 열거형은 값 타입(Value Type)입니다.

이러한 차이점을 고려하여 클래스, 구조체, 열거형 중 어떤 것을 사용할지 선택해야 함.

클래스의 성능을 향상시키기 위해서는 다음과 같은 방법을 고려할 수 있습니다:

1. 불필요한 객체 생성 피하기:
   - 불필요한 객체 생성은 메모리 사용과 성능에 부담을 줄 수 있습니다. 객체를 반복적으로 생성하는 대신 객체 풀(Object Pool)을 사용하거나 캐시를 활용하여 객체 재사용을 고려해야 합니다.

2. 레퍼런스 사이클과 메모리 누수 방지:
   - 클래스의 레퍼런스 사이클을 주의하고, 강한 순환 참조(Strong Retain Cycles)를 방지하기 위해 weak, unowned 참조를 사용합니다.
   - `deinit` 메서드를 활용하여 객체가 더 이상 필요하지 않을 때 자원을 정리하는 코드를 구현합니다.

3. 값 타입 사용:
   - 클래스보다 구조체(struct)나 열거형(enum)을 사용하는 것이 메모리 관리와 성능면에서 더 효율적일 수 있습니다. 특히 데이터의 불변성을 유지할 수 있다면 값 타입을 사용하는 것이 좋습니다.

4. 지연 초기화(Lazy Initialization):
   - 객체의 속성 중 초기화가 비용이 큰 경우, 해당 속성을 처음 사용할 때까지 초기화를 미루고 필요할 때 초기화를 진행할 수 있습니다. 이를 위해 `lazy` 키워드를 사용할 수 있습니다.

5. 효율적인 알고리즘 선택:
   - 데이터 처리나 연산을 수행할 때 효율적인 알고리즘을 선택하고 최적화합니다. 적절한 자료구조를 사용하여 검색, 삽입, 삭제 등의 연산을 빠르게 처리합니다.

6. 멀티스레딩 및 비동기 프로그래밍:
   - 멀티스레딩 및 비동기 프로그래밍을 사용하여 병렬 처리를 활용하고, 작업을 효율적으로 분배하여 성능을 향상시킬 수 있습니다.

7. 인스턴스 변수 접근 최적화:
   - 필요한 경우 `private`나 `fileprivate` 접근 제어자를 사용하여 변수를 보호하고 직접 접근하는 대신 getter와 setter 메서드를 사용하여 접근합니다.

8. 코드 프로파일링과 최적화:
   - 코드 프로파일링 도구를 사용하여 성능 병목 현상을 파악하고, 성능을 향상시킬 수 있는 부분을 식별한 후 최적화 작업을 수행합니다.

9. 캐싱 활용:
   - 데이터나 연산 결과를 캐싱하여 불필요한 계산을 피하고 성능을 향상시킬 수 있습니다.

10. 불필요한 작업 최소화:
    - 불필요한 반복문, 연산, 네트워크 호출 등을 최소화하고, 필요한 작업만 수행하도록 설계합니다.

성능 향상을 위한 접근 방법은 상황에 따라 다를 수 있으며, 프로젝트의 특성과 요구 사항에 따라 적절한 방법을 선택하는 것이 중요합니다. 코드 최적화는 항상 프로파일링과 테스팅을 통해 검증되어야 하며, 성능 개선 후에도 코드의 가독성과 유지보수성을 유지하는 것이 중요합니다.

구조체(structure), 일반적으로 구조체라고 부르며, Swift 프로그래밍 언어에서 데이터를 구조화하고 다루는 데 사용되는 중요한 데이터 타입입니다. 구조체는 다음과 같은 특징을 갖습니다:

1. 값 타입(Value Type): 구조체는 값 타입으로 처리됩니다. 이는 구조체 인스턴스를 생성할 때 해당 값을 복사한다는 의미입니다. 따라서 하나의 구조체 인스턴스를 수정해도 다른 인스턴스에는 영향을 주지 않습니다.

2. 멤버 변수와 메서드: 구조체는 멤버 변수(프로퍼티)와 메서드를 가질 수 있습니다. 이를 사용하여 데이터와 그 데이터를 다루는 동작을 함께 묶을 수 있습니다.

3. 초기화 메서드: 구조체는 사용자 정의 초기화 메서드를 가질 수 있으며, 초기화 메서드를 사용하여 구조체 인스턴스를 생성 및 초기화할 수 있습니다.

4. 상속 불가능: 구조체는 클래스와 달리 상속을 지원하지 않습니다. 따라서 다른 클래스나 구조체를 기반으로 새로운 구조체를 만들 수 없습니다.

5. 자동으로 생성되는 멤버 초기화자: Swift에서는 구조체에 대한 멤버 초기화자를 자동으로 생성해 줍니다. 이로써 기본값을 가진 멤버 변수를 가지는 구조체의 인스턴스를 간편하게 생성할 수 있습니다.

클래스 메서드(Class Method)와 정적 메서드(Static Method)는 객체 지향 프로그래밍에서 메서드 호출 방식과 의미에서 차이가 있습니다. 다음으로 두 가지 유형의 메서드 간의 주요 차이를 설명하겠습니다:

1. 클래스 메서드 (Class Method):

   - 클래스 메서드는 특정 클래스 자체에 연결되는 메서드입니다. 객체 인스턴스에 종속되지 않으며 클래스 레벨에서 호출됩니다.
   - 클래스 메서드는 `static` 키워드나 `class` 키워드를 사용하여 정의할 수 있습니다. Swift에서는 `class` 키워드를 사용하는 것이 좋습니다.
   - 클래스 메서드 내부에서는 `self` 키워드를 사용하여 클래스 자체에 접근할 수 있습니다.
   - 주로 클래스 수준의 작업을 수행하며, 클래스의 속성이나 메서드를 수정할 때 사용됩니다.
   - 클래스 메서드는 상속될 수 있으며, 서브클래스에서 재정의(override)할 수 있습니다.

   ```swift
   class MyClass {
       class func myClassMethod() {
           // 클래스 메서드 내용
       }
   }

   MyClass.myClassMethod()
   ```

2. 정적 메서드 (Static Method):

   - 정적 메서드도 클래스 메서드와 유사하게 객체 인스턴스와는 독립적으로 클래스 자체에 연결됩니다.
   - 정적 메서드는 명시적으로 `static` 키워드를 사용하여 정의됩니다. Swift에서는 주로 `class` 대신 `static`을 사용합니다.
   - 클래스 메서드와 마찬가지로 클래스 수준의 작업을 수행하며, 클래스의 속성이나 메서드를 수정할 때 사용됩니다.
   - Swift에서는 정적 메서드를 상속할 수 없으며, 서브클래스에서 재정의할 수 없습니다.

클래스 메서드와 정적 메서드는 어떤 유형의 메서드를 사용할지에 따라 프로그램 설계에 영향을 미칩니다. 클래스 메서드는 상속 가능하며 다형성을 지원하므로 클래스 계층 구조에서 메서드를 공유하고 확장하는 데 유용합니다. 정적 메서드는 클래스의 도우미 메서드나 유틸리티 함수를 구현할 때 유용하며, 인스턴스와 독립적으로 작동해야 하는 경우에 사용됩니다.
