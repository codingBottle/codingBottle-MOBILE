# 23.11.22 \_ AD 8주차

## Q : @main에 대해서 설명하시오

## @main 이란?

- 이는 `AppDelegate` 에서 사용되는 어노테이션으로 해당 어플의 **entry point**를 알려주는 역할을 합니다.
  > **AppDelegate 란:**
  >
  > - 앱이 시작되는 진입점을 알려줌과 더불어 앱의 입력이벤트를 전달하는 루프를 생성하는 역할을 하는 것 입니다.
- @main 이전으로 위의 역할을 하던 것은 `@UIApplicationMain` 이 있습니다.
  ![이미지1](https://github.com/ParkSY0919/GithubActionsTest/assets/114901417/7672f737-c8e7-4e94-b449-9e180f4be8e2)
- 이는 탑 레벨의 코드를 작성하는 것 대신 사용자는 single type에 @main 속성을 사용할 수 있습니다.
  ![이미지 2](https://github.com/ParkSY0919/GithubActionsTest/assets/114901417/e86e1f64-ad66-4aeb-bbc4-5bb3d681bb48)
  > **Top-Level Code 란?**
  >
  > - Swift에서 "top-level code"는 전역 범위(global scope)에서 직접 실행되는 코드를 의미합니다. 이는 함수, 클래스, 구조체, 열거형 등의 외부에 있는 코드를 말합니다.
  > - 그러나 실제 앱 개발에서는 `@UIApplicationMain` 또는 `@main` 어노테이션을 사용하여 앱의 시작점을 지정하고, top-level code는 거의 사용하지 않습니다. 이는 앱의 생명주기를 관리하기 위해 필요한 코드를 작성하고, 앱의 구조를 명확하게 표현하기 위한 것입니다.
  - 따라서 위의 `탑 레벨의 코드를 작성하는 것` 에 해당 하는 것은 @main이 등장하기 이전에 쓰인 @UIApplicationMain 속성인 것입니다.

## \***\*@UIApplicationMain 란?\*\***

- Swift기반의 Xcode 프로젝트에서 Mac 템플릿을 생성하면 기본적으로 "main.swift" 파일을 포함하여 main함수를 쉽게 찾을 수 있지만, Xcode에서 새 iOS 프로젝트를 만들고 앱이 어디서 부터 시작되는지 알기위해 main() 함수 혹은 "main.swift" 파일을 찾아 보면, 쉽게 찾을 수가 없습니다.
- 그 이유는 iOS 기본 템플릿에선 Swift파일에 @UIApplicationMain을 포함 함으로써 컴파일러가 iOS 앱의 진입점을 합성하기 때문에 따로 "main.swift"파일이 필요하지 않았기 때문입니다.
- main()함수가 존재하지 않는 것은 아닙니다. Swift기반의 iOS프로젝트에서는 UIKit 프레임워크가 이를 숨겨서 관리하기에 찾기 힘들었던 것입니다.
- **기능**
  - 앱의 본체에 해당하는 객체인 UIApplicaion객체를 생성, 이 객체는 앱의 Life Cycle을 관리합니다.
  - 지정된 클래스(@UIApplicationMain이 표시된)에서 델리게이트를 인스턴스화 하고 이를 앱의 객체에 할당합니다.
  - 앱의 Run Loop을 포함한 기본 이벤트처리 루프를 설정하고 이벤트 처리를 시작합니다.
  - 앱의 info.plist에 불러올 main nib파일이 제대로 명시되어있으면, 해당 nib파일을 불러옵니다 (유저 인터페이스를 불러옵니다.)

> <aside>
> ❓ **UIApplicationMain 함수는 반환값이 Int32로 되어있음에도 어째서 반환을 하지 않는가?**
>
> ![이미지 3](https://github.com/ParkSY0919/GithubActionsTest/assets/114901417/6e5b74ac-fefb-413c-8d11-d2994208404e)
>
> - 일반적인 Unix 기반 시스템에서 프로그램이 종료될 때 반환하는 종료 코드를 위한 것이나, iOS 애플리케이션은 이벤트 주도형(event-driven)으로 동작하기에 사용자가 앱을 강제로 종료하거나 시스템이 앱을 종료시키기 전까지 `UIApplicationMain` 함수는 이벤트 루프(event loop)에서 계속 실행됩니다.
> - 따라서 `UIApplicationMain` 함수의 반환값은 실제 iOS 앱 개발에서는 거의 사용되지 않습니다. 그러나 이 함수의 선언에서는 Unix 프로그램의 표준적인 형태를 따르고 있어서 반환값이 `Int32`로 선언되어 있는 것입니다.
> </aside>

## 어째서 @main으로 넘어왔는가?

- 스위프트 프로그램은 소스파일의 시작점 부터 시작하고 특별한 구문없이 절차적 코드에서 훌룡하게 작동하지만, 사용자용 앱의 경우 종료 될 때까지 계속해서 실행 됨과 더불어 UIKit 및 AppKit과 같은 사용자 인터페이스 프레임 워크는 애플리케이션 실행의 복잡성을 처리하여 앱 동작을 정의하기위한 고급 API 후크를 제공합니다.
- 위의 두 모델을 해결하기 위해 앱은 프레임 워크의 기본 실행 시작점을 정하고 시작하기 위해 소량의 “부팅 로딩” 코드가 필요하게 됩니다.
- 이 때 초기에는 @UIApplicationMain 및 @NSApplicationMain 도메인이 명시된 속성을 제공했으나, 이처럼 프레임워크에 연결된 속성을 사용하는 것 보다 지정된 타입(@main으로 명시된)을 사용하여 보다 더 가벼운 매커니즘을 제공하는 것이 스위프트의 타입 기반 시스템에 더욱 맞는 패턴이라고 생각하여 @main으로 넘어오게 되었습니다.

## 어떻게 @main으로 entry point를 알려주는가?

```markdown
# Swift 컴파일러

// In a framework:
public protocol ApplicationRoot {
// ...
}
extension ApplicationRoot {
public static func main() {
// ...
}
｝

// In MyProgram. swift:
@main
struct MyProgram: ApplicationRoot {
// ...
｝
```

- Swift 컴파일러는 @main이 달린 타입 struct MyProgram을 프로그램 진입점으로 인식하며, 이 타입은 정적 main() 메소드를 선언하는 하나의 요구사항을 충족하면 됩니다.
- 프로그램이 시작되면 @main으로 표시된 타입에서 정적 main ()메서드가 호출되는 것이죠.

> ### AppDelegate.swift 의 경우
>
> ```swift
> import UIKit import CoreData
>
> @main
> class AppDelegate: UIResponder, UIApplicationDelegate {
> func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions:
> 	[UIApplication.LaunchOptionsKey: Any]?) →> Bool {
> 	// Override point for customization after application launch.
> 	print("app launched!")
> 	return true
> ｝
> ```
>
> - @main로 표시해줌으로서 프로그램의 진입점은 AppDelegate 클래스이고 UIApplicationDelegate 프로토콜에 작성된 정적 main() 함수를 호출하게 됩니다.

## 요약

- 어떤 UI 프레임워크든 상관없이 특정한 목적을 위한 속성(UIKitd와 AppKit의 @UIApplicationMain 및 @NSApplicationMain)보다 @main을 사용함으로써 일관성을 추구하고 더욱 간편한 진입점을 제공합니다.
- 또한 @UIApplicationMain대신 @main속성을 사용함으로써 타입 기반의 스위프트 코드에서 이상적인 프로그램 진입점을 알려줄 수 있다.
- main()함수는 일반 정적 메서드이므로 프로토콜에서 확장 메서드 또는 기본 클래스로 제공 할 수 있으며, 이를 통해 프레임 워크는 추가 언어 기능 없이도 사용자 지정 진입점 동작을 쉽게 정의 할 수 있게됩니다. (아래 예시)
  ![이미지 4](https://github.com/ParkSY0919/GithubActionsTest/assets/114901417/dcb37bf3-1346-427a-a9ed-8fcfc688653b)
  ![이미지 5](https://github.com/ParkSY0919/GithubActionsTest/assets/114901417/f68f3fe3-abe9-49ce-b631-ce4f7afb0335)
  ![이미지 6](https://github.com/ParkSY0919/GithubActionsTest/assets/114901417/c31ca7b0-3ec3-4673-a5dc-9be44593aa71)

### ⚠️ 참고:

- [https://barosalki.tistory.com/entry/iOS-Swift-53-main-type기반의-프로그램-진입점](https://barosalki.tistory.com/entry/iOS-Swift-53-main-type%EA%B8%B0%EB%B0%98%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%A7%84%EC%9E%85%EC%A0%90)

---

<br></br>

## Q : 함수형 프로그래밍이 무엇인지 설명하시오

## 두가지 형태의 세가지 프로그래밍

- 명령형 프로그래밍 : 무엇(What)을 할 건지를 나타내기보다 어떻게(How)를 할 건지 설명하는 방식
  - 절차 지향 프로그래밍 : **수행되어야 할 기능을 `순차적인 처리 과정으로 진행`하는 방식**
  - 객체지향 프로그래밍 : **`객체들의 집합`으로 프로그램의 `상호작용으로 진행`하는 방식**
- 선언형 프로그래밍 : 어떻게(How)를 할 건지를 나타내기보다 무엇(What)을 할 건지 설명하는 방식
  - 함수형 프로그래밍 : **`순수 함수를 조합`하여 소프트웨어를 만드는 방식**

## 절차 지향 프로그래밍 **(Procedure Programming)**

- 정의

  > **프로그램을 일련의 절차 또는 루틴으로 분해하는 프로그래밍 패러다임으로, 데이터와 함수를 별도로 취급하며, 작업을 수행하기 위해 데이터가 함수를 통과하는 '절차'를 중심으로 프로그램을 구성합니다.
  > 즉, 일이 진행되는 순서대로 프로그래밍 하는 방법입니다.**

- 장, 단점
  > 장점:
  >
  > - **프로그램의 흐름이 명확하기에 가독성이 좋습니다.**
  > - **구조적인 프로그래밍 방식으로 컴퓨터 처리방식과 유사해, 작은 프로그램이나 단순한 애플리케이션을 빠르게 개발하는 데 유리하며, 실행 속도 역시 빠릅니다.**
  >
  > 단점:
  >
  > - **코드의 재사용성이 낮고, 유지 보수가 어렵습니다.**
  > - **데이터와 함수가 별도로 존재하기에 실체의 객체를 모델링하기 어렵습니다.**
- PP를 대체할 것
  > **객체 지향 프로그래밍(OOP)로 이는 데이터와 함수를 하나의 '객체' 단위로 묶어서 관리하며, 객체 간의 상호작용을 통해 프로그램을 구현하기에 재사용성과 유지보수성을 향상시키고, 실제 복잡한 문제를 보다 자연스럽게 모델링하며 PP의 단점을 극복하였습니다.**

## **객체지향 프로그래밍? (Object Oriented Programming)**

- 정의
  > **이는 프로그램을 '객체'라는 기본 단위로 나누고 이 객체들이 서로 상호작용하는 방식으로 프로그램을 설계하고 구현하는 방법으로, 객체는 `데이터`와 이 데이터를 조작하는 `함수(메서드)`를 `하나로 묶은 것을 의미`하며, 이를 통해 실제 사물이나 개념을 프로그램 안에서 쉽게 모델링할 수 있습니다.**
- 장, 단점
  > 장점:
  >
  > - **객체 단위로 코드가 구분되어 있어 코드의 재사용성이 높아져, 유지 보수가 용이합니다.
  >   따라서 `코드의 재사용이 가능`합니다.**
  > - **데이터와 함수를 하나의 단위로 묶어 데이터 보호가 가능합니다.**
  >
  > 단점:
  >
  > - **객체 간의 상호작용이 복잡해지면서 실행 속도가 느려질 수 있습니다.**
  > - **메모리 사용량이 다른 프로그래밍 방식에 비하여 많을 수 있습니다.**
  > - **데이터와 함수가 별도로 존재하기에 실체의 객체를 모델링하기 어려워 설계단계에서 많은 시간이 소요됩니다.**
- 특징
  > 1. 추상화: 공통적인 속성이나 기능을 묶어 이름을 붙이는 것입니다.
  >
  > 2. 캡슐화: 데이터를 은닉하고 데이터 기능을 노출시키지 않는 것입니다.
  >
  > 3. 상속성: 상위 부모 객체의 속성과 특징을 하위 객체가 물려 받는 것입니다.
  >    (만약 어떠한 객체가 이미 존재하는 객체의 특성을 가지고 있다면, 기존 객체의 특성을 상속시켜 만들 수 있습니다.)
  >
  > 4. 다형성: 같은 함수가 있어도 매개변수에 따라 각자 다른 일을 하는 것입니다.
- OOP를 대체할 것
  > **함수형 프로그래밍(FP): 이는 프로그램을 순수 함수의 계산으로 보는 방식으로, 사이드 이펙트를 최소화하고 불변성을 강조하는 특징을 가지기에 복잡한 프로그램도 간결하고 예측 가능한 코드로 작성할 수 있습니다.
  > 따라서 위 객체지향의 단점을 보완할 수 있습니다.**

## 함수형 프로그래밍 **(Functional Programming)**

- 정의

  > **프로그램을 순수 함수의 모음으로 보고, 이 함수들의 결합으로 전체 프로그램을 구성하는 방식을 말합니다.
  > 이는 데이터의 상태 변화를 최소화하고 사이드 이펙트를 줄이는 것을 목표로 합니다.**

- 장, 단점
  > 장점:
  >
  > - **함수의 입력만을 기반으로 출력을 생성하기 때문에, 같`은 입력에 대해서는 항상 동일한 결과를 반환하므로 예측 가능`합니다.**
  > - **상태를 변경하지 않기 때문에, `병렬 처리와 같은 멀티스레드 환경에서 안전하게 사용`할 수 있습니다.**
  > - **코드의 간결성과 모듈성이 높아져 `코드 재사용성이 높아집니다.`**
  >
  > 단점:
  >
  > - **일부 상황에서는 데이터의 상태 변경이 필요하거나 효율적인데, `함수형 프로그래밍은 외부 데이터 혹은 내부 데이터의 상태를 조작할 수 없습니다.`**
- FP를 대체할 것
  > **객체 지향 프로그래밍(OOP)로 이는 실제 사물이나 개념을 객체로 다루는 방식으로 외부 데이터와 내부 데이터를 조작할 수 있기에 함수형 프로그래밍의 단점을 보완할 수 있습니다.**

## 객체지향과 함수형의 차이?

1.  **함수형 프로그래밍에서는 함수(Function) 자체가 일급 객체가 되지만, 객체지향 프로그래밍에서는 클래스(또는 객체, Object)가 일급 객체가 됩니다.**
    - 일급 객체란?
      - 다른 요소들과 아무런 차별이 없는 객체.
      - 즉, 함수의 인자로도 넘겨질 수 있고, 변수에 대입도 가능한 객체를 일급 객체.
    - 일급 객체의 명확한 정의
      - 모든 일급 객체는 함수의 실질적인 매개변수가 될 수 있음.
      - 모든 일급 객체는 함수의 반환값이 될 수 있음.
      - 모든 일급 객체는 할당의 대상이 될 수 있음.
      - 모든 일급 객체는 비교 연산(==, equal)을 적용할 수 있음.
2.  **객체지향 프로그래밍에서는 프로그램을 상호작용(interaction)하는 객체들의 집합으로 볼 수 있지만, 함수형 프로그래밍에서는 상태 값을 지니지 않는 함수들의 연속으로 볼 수 있습니다.**
    - 객체지향 프로그래밍의 경우
      - 클래스 디자인과 객체들의 관계를 중심으로 코드 작성이 이루어짐.
      - 따라서, 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있음.
      - 특히, 멤버변수가 어떤 상태를 가지고 있는가에 따라 결과가 달라짐.
    - 함수형 프로그래밍의 경우
      - 값의 연산 및 결과 도출 중심으로 코드작성이 이루어짐.
      - 함수는 인자로 받은 값을 별도로 저장하지 않고, 간결한 과정으로 처리하고 매핑하는데에 주 목적을 둠.

### 차이점 결론:

- 어느 하나가 우위에 있다는 것 보다, 필요에 따라 합쳐서 사용하기도 하고 원하는 목표에 따라 적절한 것을 잘 골라 사용해야합니다.

### ⚠️ 참고:

- [https://velog.io/@majaeh43/절차지향-객체지향-함수형-프로그래밍](https://velog.io/@majaeh43/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

---
