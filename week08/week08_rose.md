# 8주차

# **@Main에 대해서 설명하시오.**

## **기본 개념**

- @Main은 애플리케이션의 진입점을 정의하는 어노테이션, 이 어노테이션은 애플리케이션의 생명 주기를 관리하는 객체를 지정
- SwiftUI에서는 @UIApplicationDelegateAdaptor를 사용하여 기존의 AppDelegate와 함께 작동하도록 만들 수 있지만, @Main을 사용하면 애플리케이션의 생명 주기를 SwiftUI 방식으로 관리할 수 있음

## 사용 방법

- @Main은 애플리케이션의 시작점을 표시하는 역할을 하므로, 애플리케이션의 생명 주기를 관리하는 구조체나 클래스에 붙여 사용함
- 이 구조체나 클래스는 Application 프로토콜을 준수해야 함. Application 프로토콜에는 애플리케이션의 생명 주기를 관리하기 위한 메서드들이 정의되어 있음

## 주의 사항

- 프로젝트 내에 @Main 어노테이션이 붙은 클래스나 구조체는 하나만 있어야 함 ⇒ 둘 이상 존재하면 컴파일 에러가 발생
- @Main은 애플리케이션의 생명 주기를 관리하는 객체를 지정하기 때문에, 해당 객체에서 애플리케이션의 초기 설정을 수행하거나 애플리케이션의 상태를 관리하는 등의 역할 수행

**@Main 어노테이션은 애플리케이션의 생명 주기를 관리하는데 어떤 방식으로 이점을 제공하나요?**

- 초기화와 설정: 애플리케이션 시작 시점에 일어나는 초기화와 설정 작업을 명확하게 관리
    
    ⇒ 애플리케이션에 필요한 리소스 로딩, 데이터베이스 연결 설정 등의 작업 포함
    
- 상태 관리: 애플리케이션의 상태 변화를 감지하고 적절한 처리를 수행함
    
    ⇒ 예를 들어, 애플리케이션이 백그라운드로 전환될 때 현재 상태를 저장하거나, 애플리케이션이 다시 활성화될 때 필요한 업데이트를 수행하는 등의 작업 수행
    
- 정리 작업: 애플리케이션이 종료될 때 필요한 정리 작업을 수행
    
    ⇒ 사용 중이던 리소스를 해제하거나, 데이터베이스 연결을 닫는 등의 작업 포함
    
- 단순화와 명확성: @Main 어노테이션을 사용하면 애플리케이션의 진입점이 명확해짐, 애플리케이션의 생명 주기를 관리하는 코드가 한 곳에 집중되어 코드의 복잡성을 줄이고 가독성 향상

# 함수형 프로그래밍이 무엇인지 설명하시오.

## 정의

- 프로그래밍 패러다임 중 하나로, 계산을 수학적 함수의 평가로 취급하고 상태 변경과 가변 데이터를 피하는 것을 강조
    
    ⇒ 코드를 더욱 간결하고 예측 가능하게 만드는 데 도움됨
    

## 특징

### 순수 함수

- 같은 입력에 대해 항상 같은 출력을 반환하며, 외부 상태를 변경하지 않고 부작용이 없는 함수
- 함수의 예측 가능성과 재사용성 높여줌

### 불변성

- 예측 가능성
    - 불변성을 유지하면 데이터가 언제, 어디서 변경될지에 대한 불확실성을 제거할 수 있음 ⇒ 코드의 동작을 예측하기 쉽게 만들며, 버그 발생 가능성을 줄임
- 일관성
    - 데이터의 상태가 변하지 않기 때문에, 프로그램의 일관성을 유지하는데 굿
- 병렬 처리 용이성
    - 불변 데이터는 동시에 여러 처리에서 안전하게 사용됨 ⇒ 병렬 처리나 멀티 스레딩 환경에서의 안정성 보장
- 불변성을 유지하면서 데이터를 처리하려면?
    - 새로운 상태를 필요로 하는 경우 기존 데이터를 변경하는 대신 새로운 데이터를 생성하는 방식을 사용해야 함
    - 예를 들어, 리스트에 새로운 요소를 추가하려는 경우 기존 리스트를 변경하는 것이 아니라 새로운 요소가 추가된 새 리스트를 생성함

### 고차 함수

- 다른 함수를 인자로 받거나, 함수를 결과로 반환할 수 있는 함수
- 코드의 재사용성을 높이고 코드의 복잡성을 줄일 수 있음
- EX) 배열의 각 요소에 어떤 함수를 적용하는 'map' 함수 : 적용하고 싶은 함수를 인자로 받아 배열의 각 요소에 적용하므로, 동일한 로직을 반복적으로 작성하지 않아도 됨
- 커링
    - 여러 개의 인자를 가진 함수를 단일 인자를 받는 함수들의 연속으로 변환하는 기법, 함수 f(a, b, c)를 f(a)(b)(c)로 변환하는 것 ⇒ 코드의 재사용성 높임
    - 일부 인자만 받아서 새로운 함수를 생성할 수 있음 ⇒ 이렇게 생성된 함수는 나중에 나머지 인자를 받아서 사용할 수 있으므로, 동일한 로직을 반복적으로 작성하지 않아도 됨

⇒ 고차 함수와 커링을 활용하면, 코드의 재사용성을 높이고, 복잡성을 줄일 수 있음

### 레이지 평가

- 필요한 시점까지 데이터 생성을 미루는 기법 ⇒ 표현식이 실제로 필요할 때까지 그 결과 계산 X
- 성능을 최적화하고, 무한 데이터 구조를 다루는 등의 장점을 얻을 수 있음
- 효율성: 필요한 시점에만 계산을 수행하므로, 불필요한 계산을 피하고 메모리를 절약. 예를 들어, 무한 시퀀스를 다룰 때 모든 요소를 즉시 계산하는 것은 불가능하지만, 지연 평가를 사용하면 필요한 요소만을 계산할 수 있음
- 모듈성: 함수의 호출과 결과의 사용을 분리할 수 있으므로, 코드의 모듈성을 향상시킴
- 함수의 합성: 함수의 합성을 통해 복잡한 연산을 단순하게 표현할 수 있음. 각 함수가 결과를 즉시 반환하지 않고, 다음 함수가 필요로 할 때만 계산을 수행하므로, 중간 결과를 저장할 필요가 없음
- 단점 - 계산 시점을 추적하기 어렵게 만들어 디버깅을 어렵게 할 수 있으며, 메모리 사용량을 예측하기 어렵게 만듦

## 장점

- 예측 가능성
    - 순수 함수는 외부 상태에 의존하지 않고 외부 상태를 변경하지 않음
    - 같은 입력에 대해 항상 같은 결과를 반환하므로, 코드의 실행 결과를 예측하기 쉬움
- 불변성
    - 함수형 프로그래밍에서는 데이터를 변경하지 않고 새로운 데이터를 생성하여 반환함
    - 상태 변경에 의한 버그를 줄이고, 코드의 안정성을 높이는데 도움됨
- 재사용성과 모듈성
    - 고차 함수를 사용하면, 함수를 인자로 전달하거나 결과로 반환 가능
    - 코드의 재사용성을 높이고, 더 작은 단위로 함수를 분리하여 코드의 모듈성을 향상시킴
- 테스트와 디버깅 용이성
    - 순수 함수는 독립적으로 테스트할 수 있으며, 부작용이 없기 때문에 디버깅이 용이함
- 병렬 처리와 동시성
    - 함수형 프로그래밍에서는 데이터의 불변성이 보장되므로, 병렬 처리와 동시성을 안전하게 다루는데 유리함
    - 멀티코어나 분산 환경에서의 프로그래밍에 장점 제공
- 레이지 평가
    - 함수형 프로그래밍은 필요한 시점까지 계산을 미루는 레이지 평가 지원
    - 성능을 최적화하고, 무한한 크기의 데이터 구조를 다룰 수 있음

## 단점

- 학습 곡선
    - 함수형 프로그래밍은 명령형 프로그래밍과는 다른 패러다임을 가지고 있기 때문에, 처음 접하는 개발자들에게는 생소하고 이해하기 어려울 수 있음
    - 특히, 고차 함수, 순수 함수, 레이지 평가 등의 개념을 이해하고 익히는데 시간이 필요함
- 디버깅의 어려움
    - 함수형 프로그래밍에서는 함수의 호출 결과가 다른 함수의 입력으로 연쇄적으로 사용되는 경우가 많음
    - 오류가 발생했을 때, 그 원인을 찾기 어려울 수 있음
    - **순수 함수가 아닌 함수를 사용할 때 디버깅이 어려운 이유가 뭔가요?**
        - 예측 가능성 감소: 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환함 ⇒ 그 결과를 예측하기 쉬움 / 부작용을 가진 함수는 외부 상태에 의존하거나 외부 상태를 변경 가능 ⇒ 함수의 행동을 예측하기 어렵고, 이는 디버깅 과정에서 어려움을 초래할 수 있음
        - 상태 추적의 어려움: 부작용을 가진 함수는 외부 상태를 변경 가능 ⇒ 프로그램의 전체 상태를 추적하기 어려워짐. 어떤 함수가 어떤 상태를 변경했는지, 그 변경이 어떤 영향을 미쳤는지 파악하기 어려워, 디버깅이 복잡해질 가능성 있음
        - 테스트의 어려움: 부작용을 가진 함수는 그 결과가 외부 상태에 의존하므로, 독립적으로 테스트하기 어려움 ⇒ 오류를 빠르게 찾아내고 수정하는데 어려움이 있을 수 있음
- 성능 이슈
    - 함수형 프로그래밍에서는 불변성을 유지하기 위해 데이터를 복사하는 경우가 많음
    - 메모리 사용량이 증가하고, 성능이 저하될 수 있음
    - 레이지 평가는 필요할 때만 계산을 수행하므로 성능 이점을 가져다주지만, 예측하지 못한 시점에 불필요한 계산이 발생할 수 있음
- 하드웨어 최적화의 한계
    - 함수형 프로그래밍은 순수 함수와 불변성을 통해 병렬 처리와 동시성을 잘 지원하지만, 이는 CPU 캐시와 같은 하드웨어 최적화를 이용하기 어렵게 만들 수 있음

**함수형 프로그래밍에서는 일반적으로 반복문을 사용하지 않고, 대신 재귀를 사용합니다. 그 이유는 무엇인가요?**

- 불변성(immutability)와 순수 함수(pure functions)라는 개념을 중요
    
    ⇒ 원칙들은 상태 변경이나 데이터 변형을 최소화하려는 목표와 잘 부합하는데, 이는 반복문의 사용이 이러한 원칙들을 위반하기 쉽기 때문
    
- 반복문은 일반적으로 반복적인 작업을 수행하기 위해 변수의 상태를 변경하며 사용
    
    ⇒ 불변성 원칙에 어긋남, 반복문 내부에서 부작용을 발생시키는 경우가 많아 순수 함수의 원칙을 지키기 어려움
    
- 재귀는 함수가 자기 자신을 호출함으로써 반복적인 작업을 수행
    
    ⇒ 상태 변경 없이 동작하므로 불변성 원칙을 지키기 쉬움, 재귀적인 함수는 입력만을 기반으로 결과를 도출하므로 순수 함수의 원칙을 지킬 수 있음
    

⇒ 반복문 대신 재귀를 사용하여 로직을 구현하는 것이 일반적. 하지만 재귀의 사용은 스택 오버플로우와 같은 문제를 일으킬 수 있으므로, 실제 구현 시에는 이러한 점을 고려해야 함

**함수형 프로그래밍이 병렬처리와 동시성 문제를 해결하는 데 어떻게 도움이 되나요?**

- 데이터의 불변성과 순수 함수라는 개념을 중심으로 한다는 점에서, 병렬처리와 동시성 문제를 해결하는 데 큰 도움줌
- 데이터의 불변성 : 데이터가 한번 생성된 이후에 변경되지 않음 ⇒ 여러 스레드나 프로세스가 동시에 데이터에 접근하더라도 데이터가 변경되지 않기 때문에, 병렬처리와 동시성 환경에서의 데이터 경쟁 조건이나 교착 상태와 같은 문제를 피할 수 있음
- 순수 함수 : 동일한 입력에 대해 항상 동일한 출력을 반환하며 부작용이 없음 ⇒ 순수 함수는 병렬로 실행하거나 재배치하는 것이 안전하므로, 병렬처리와 동시성을 쉽게 구현할 수 있음
- 지연 평가, 고차 함수, 커링 등 병렬처리와 동시성을 지원하는 강력한 기능들을 제공