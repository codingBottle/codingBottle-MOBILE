# 3주차

## Extension에 대해 설명하시오.

### 개념

- 확장(extension) : 기존 클래스, 구조체, 열거형 또는 프로토콜 타입에 새로운 기능을 추가하는 강력한 도구
- 기존 타입을 수정하지 않고도 그 타입의 인스턴스에 메서드, 계산된 속성, 이니셜라이저 등을 추가할 수 있음
- 기본 구현에서 상속받아 오버라이딩 X
- 저장된 속성 또는 프로퍼티 객체 추가 X
- 라이브러리나 프레임워크에 포함되어 소스 코드에 직접 접근할 수 없는 객체라 할지라도 확장 구문을 이용하면 거의 제약 없이 새로운 기능을 추가 가능

**주의**

- 익스텐션은 extension 키워드를 사용할 뿐 독립적인 객체를 생성하는 구문 X
    - 이미 정의되어있는 기존 객체의 기능을 더 추가해주는 것일뿐
    
      ⇒ 익스텐션은 객체가 아니며 또한 타입으로 사용 X
    

### 역할

- **구현 가능**
    - 새로운 연산 프로퍼티 추가
    - 새로운 메서드 정의
    - 새로운 초기화 구문 추가 가능
    - 기존 객체를 수정하지 않고 프로토콜 구현 가능
- **프로토콜 준수**
    - 확장은 특정 프로토콜이 요구하는 기능들을 구현함으로써 어떤 타입이 해당 프로토콜을 준수하도록 만듦
- **유틸리티 함수 제공**
    - String, Array 등과 같은 기본 제공 데이터타입에 대한 유틸리티 함수를 확장으로 제공

### 주요 사용 사례

- 메서드 추가 : 확장을 사용하여 기존 타입에 인스턴스 메서드와 타입 메서드 추가할 수 있음
    
    ```swift
    extension Int {
        func squared() -> Int {
            return self * self
        }
    }
    
    let num = 8
    print(num.squared())  // 출력: 64
    ```
    
- 계산된 속성 추가 : 확장을 사용하여 기존 타입에 인스턴스 속성과 타입 속성 추가
    - 저장된 속성, 즉 값을 가지는 변수 또는 상수는 추가 X
    
    ```swift
    extension Double {
        var squared: Double { return self * self }
    }
    
    let num = 8.0
    print(num.squared)  // 출력: 64.0
    ```
    
- 이니셜라이저 제공 : 클래스에 편리한 이니셜라이저를 제공하는데 유용
    
    ```swift
    struct Point {
        var x: Int 
        var y: Int 
    }
    
    extension Point {
       init(_ value: Int) {
           self.x = value 
           self.y = value 
       }
    }
    
    let p = Point(10)
    ```
    
- 프로토콜 적용 : 이미 존재하는 객체 혹은 값 유형인 클래스나 구조체가 프로토콜 준수를 선언하게 할 수 있음
- 중첩 데이터타입 정의 : 중첩 데이터타입을 정의하고 이름 짓는 것 가능

### 연산 프로퍼티

- extension을 이용하면 기존 객체에 연산 프로퍼티 추가 가능
    - 저장 프로퍼티는 불가능
        - 해당 타입의 원본 정의 내부에서만 선언 가능

### 메서드

- 기존 객체에 새로운 인스턴스 메서드나 타입 메서드 정의 가능
    - 매개변수 타입을 달리하면 서로 다른 메서드가 되는 메서드 오버로딩 특성을 이용
        - 새로운 메서드 정의 가능
        - 매개변수명을 변경하여 새로운 메소드 작성 가능
    - 기존 객체에서 사용된 같은 메서드를 익스텐션에서 재정의 하는 것 X
        - 클래스 객체에서 상속으로만 할 수 있는 기능이기 때문

### 프로토콜

- 기존 타입에 대해 소스 코드에서 접근할 수 없지만 새로운 프로토콜을 채택하고 준수하기 위해 기존 타입을 확장 가능
- 코드 재사용 및 조직화
    - 프로토콜 준수 추가
        - 특정 타입이 이미 존재하는 경우 그 타입에 확장을 사용하여 새롭게 만든 프로토콜을 준수하도록 만듦
    - 기본 구현 제공
        - 확장은 특정 프로토콜에 대한 기본 구현을 제공하는 데 사용
- 프로토콜 : 유사한 동작을 가진 타입들에 대한 공통 인터페이스 정의
- 확장 : 기존 타입에 새로운 기능을 추가하여 그 기능을 재사용하고 코드를 더욱 깔끔하게 만듦

### 이니셜라이저

- 인스턴스를 초기화할 때, 인스턴스 초기화에 필요한 다양한 데이터를 전달받을 수 있도록 여러 종류의 이니셜라이저 생성
- 타입의 정의 부분에 이니셜라이저를 추가하지 않더라도 extension을 통해 이니셜라이저 추가 가능
    - extension으로 클래스 타입에 편의 이니셜라이저를 추가 가능
    - 지정 이니셜라이저는 추가 불가능
        - 지정 이니셜라이저와 디 이니셜라이저는 반드시 클래스 타입의 구현부에 위치해야 하기 때문
- extension으로 값 타입(열거형, 구조체 등)에 이니셜라이저를 추가했을 때, 해당 값 타입이 다음 조건을 모두 성립한다면, extension으로 사용자 정의 이니셜라이저를 추가한 이후에도 해당 타입의 기본 이니셜라이저와 멤버와이즈 이니셜라이저 호출 가능

**조건**

1. 모든 저장 프로퍼티에 기본값이 있다.
2. 타입에 기본 이니셜라이저와 멤버와이즈 이니셜라이저 외에 추가 사용자 정의 이니셜라이저 X
    - 멤버와이즈 이니셜라이저란?
        - 이니셜라이저를 선언 안 했는데 자동으로 기본 프로퍼티가 포함되어있는 이니셜라이저가 생성되는 것
3. extension을 통해 추가하는 이니셜라이저는 타입의 기존 이니셜라이저가 갖는 책무를 동일하게 수행해야 함
    - 이니셜라이저 호출이 종료되는 시점까지 인스턴스가 정상적으로 완벽하게 초기화하는 것을 책임져야 한다.

### **Objective- C**

**카테고리**

- 자체적인 이름
    - 카테고리 - O
    - 확장 - X
- 타입
    - 카테고리 - 클래스
    - 확장 - 클래스, 구조체, 열거형 등의 객체에도 기능 추가 가능
- 속성 추가
    - 카테고리 - 기존 클래스에 메서드 추가 O, 새로운 인스턴스 변수나 속성 추가 X
    - 확장 - 기존 타입에 계산된 속성 추가 O, 저장된 속성 추가 X
- 메서드 오버라이딩 : 서브클래스가 슈퍼클래스의 메서드를 자신의 클래스 내에서 재정의하는 것
    - 카테고리 - 원래 클래스에서 동일한 이름으로 정의된 메서드 오버라이드
    - 확장 - 원래 정의와 충돌 X, 같은 이름으로 메서드 정의하려 하면 컴파일 에러 발생

**#pragma mark 주석**

- 주석 이후에 작성된 코드를 의미적으로 그룹화하여 다른 코드로부터 구분함
- 메소드가 많아 자칫 소스 코드가 엉망이 되기 쉬운 상황에서 코드를 간결하게 정리해줌
    
    ⇒ 유지 보수도 한결 수월해지기 때문에 매우 즐겨 사용하는 문법
    
    **Swift에서 사용하지 않는 이유는?**
    
    - 전역 범위에서 블록 별로 개별 메소드를 정의하던 오브젝티브-C와 달리 스위프트에서 메소드 정의는 클래스 정의 블록 내부에 작성되기 때문

### Delegate 패턴

- // MARK 주석을 사용하여 그룹화하기
    
    ```swift
    // MARK: 테이블 뷰를 위한 프로토콜 델리게이트 구현
    extension ViewController: UITableViewDataSource, UITableViewDelegate {
    ...
    }
    ```
    
- extension 구문을 이용하여 코드를 그룹화할 때
    - 엉망된 코드를 깔끔하게 정리하기 위해 사용
- 주의
    - 키워드 “MARK”와 뒤에 오는 콜론() 기호 사이에는 공백 X

### 상속

|  | 상속 | 확장 |
| --- | --- | --- |
| 타입 | 클래스 타입만 가능 | 클래스, 구조체, 열거형, 프로토콜 등 가능 |
| 특징 | 특정 타입을 물려받아 하나의 새로운 타입을 정의하고 추가 기능을 구현하는 수직 확장 | 기존 타입에 기능을 추가하는 수평 확장 |
| 재정의(override) | 기존 기능 재정의 가능 | 기존 기능 재정의 불가능 |

### 장점

- 확장할 수 있는 기능에는 분명 제한적인 부분도 있겠지만, 직접 소스 코드를 수정할 수 없는 라이브러리나 스위프트 언어 기반을 이루는 객체들까지 모두 확장할 수 있다는 점

### 단점

- 익스텐션을 남용하면 객체의 정의를 모호하게 만들거나 각 실행 위치에 따라 서로 다른 정의로 구성된 객체를 사용하게 만드는 결과가 생김
    - 어느 위치에서는 익스텐션의 영향을 받아 추가된 프로퍼티나 메소드들이 제공되는데, 또 다른 위치에서는 익스텐션의 영향을 받지 않아 추가된 프로퍼티나 메소드들을 전혀 사용할 수 없는 경우가 생길 수 있기 때문
- 객체의 정의가 파편화되기 쉬운 까닭에 객체의 정확한 구성을 파악 어려움
    - 익스텐션이 반드시 한 곳에서만 정의되었다는 보장도 할 수 없으므로 해당 객체의 전체 구조를 보려면 전체 소스 코드를 뒤져서 파편화된 모든 익스텐션들을 모아야만 할 수도 있음

⇒ 익스텐션은 필요한 곳에서는 충분히 사용하되 남용 X, 여기저기에 분산해서 작성하기보다는 전체적인 정의와 구조를 파악할 수 있는 위치에서 작성하는 것이 좋음

## Extension 내부에서 함수를 override할 수 있는지 설명하시오.

- 확장은 기존 타입에 새로운 기능을 추가하는 방법 제공
    - 이미 존재하는 메서드, 속성 또는 서브스크립트 오버라이드 X
- override - 수직적인 확장, extension - 수평적인 확장
    
    ⇒ 둘 다 확장인 것은 맞지만, 같은 타입의 기능을 수평적으로 확장하는 곳에서 수직적 확장이 override를 쓰는 것은 논리적으로 맞지 않음
    
- Swift - 불가능, Obj-C - 가능은 함
    
    ⇒ 컴파일러가 Obj-C 와의 호환성을 위해 override 를 허용하기 때문에 일단 되지만 지양함
    

**Extension으로 추가한 함수를 override?**

- 만약 특정 메서드가 서브클래스에서 오버라이드 될 필요가 있다면 그 메서드는 원래의 클래스 정의 내부에 위치해야 함
- 해당 클래스는 서브클래스에서 재정의될 수 있도록 open 또는 public 접근 제어자로 선언돼야 함

### 확장 내부에서 override 하려면?

- 해당 함수가 속한 원본 클래스 자체를 서브클래싱해야 함
- 서브클래스 내에서 override 키워드를 사용하여 원하는 함수를 재정의해야 합니다.

## Closure에 대하여 설명하시오.

### 개념

- 이름 없이 사용할 수 있는 독립적인 코드 블록
- 익명함수, func 키워드를 이용해 이름을 붙여주는 함수들도 모두 클로저
- Named Clousre & Unnamed Closure 둘다 포함하지만, 보통 Unnamed Closure를 말한다!
    - Named Closure : 이름 있는 함수
    - Unnamed Closure : 이름 붙이지 않는 함수 (익명함수)

### 표현

- func 키워드 X
- 클로저 헤드 & 바디
    
    ```swift
    {(Parameters) -> Return Type in 
    	실행 구문
    }
    ```
    
    - 클로저 헤드 : (Parameters) → Return
    - 클로저 바디 : 실행 구문
    - 이 둘을 구분해주는 것 : in
- Parameter와 Return Type이 둘 다 없는 클로저
    
    ```swift
    let closure = { () -> () in
        print("Closure")
    }
    ```
    
- Parameter와 Return Type이 있는 클로저
    
    ```swift
    let closure = { (name: String) -> String in
        return "Hello, \(name)"
    }
    ```
    
    - 클로저에선 Argument Label을 사용 X
        - name은 Argument Label이 아니고, 오직 Parameter Name!!

### 객체

- 클로저를 변수나 상수에 대입
    - 이 대입된 변수나 상수로 실행도 가능
    - 대입과 동시에 클로저를 작성 가능
    - 기존에 클로저를 대입한 변수나 상수를 새로운 변수나 상수에 대입 가능
- 함수의 파라미터 타입으로 클로저를 전달
    
    ```swift
    func doSomething(closure: () -> ()) {
        closure()
    }
    ```
    
    - 파라미터로 **함수**를 넘겨줘도 되지만
    
    ```swift
    doSomething(closure: { () -> () in
        print("Hello!")
    })
    ```
    
    - 클로저를 넘겨줘도 됨
    - Argument Label의 Parameter로 전달된 것
- 함수의 반환 타입으로 클로저 사용
    
    ```swift
    func doSomething() -> () -> () {
        
        return { () -> () in
            print("Hello Sodeul!")
        }
    }
    ```
    
    - 실제 값을 return할 때, 함수가 아닌 클로저 리턴
    - 빈괄호를 사용하여 반환값이 없음을 명시적으로 표현

### 매개변수가 없는 클로저

- 나의 매개변수를 받아들이고 아무것도 return 하지 않는 클로저
- 하나의 매개변수를 받아들이고 Bool을 return하는 클로저

### 후행 클로저

- 함수의 마지막 인자로 전달되는 클로저를 함수 호출의 괄호 바깥에 위치시키는 문법적 설탕(Syntactic Sugar)
- 함수에 대한 마지막 매개 변수가 클로저인 경우, 후행클로저 구문이라는 특수 구문을 사용
- 클로저를 매개변수로 전달하는 대신 { } 안의 함수 바로 뒤에 전달
    - 후행 클로저 사용 시 가독성 굿

**주의**

- 매개변수가 하나 이상이고 마지막 매개변수가 클로저일 때만 후행클로저 문법을 사용할 수 있다는 것

### 트레일링 클로저

- 함수의 마지막 인자 값이 클로저일 때, 이를 인자값 형식으로 작성하는 대신 함수의 뒤에 꼬리처럼 붙일 수 있는 문법

주의

- 함수의 마지막 인자값에만 적용
- 만약 인자값이 하나라면
    - 첫번째 인자값이지만 동시에 마지막 인자값이므로 트레일링 클로저 문법 사용 가능

## Closure와 함수와의 관계에 대해 설명하시오.

### 공통점

- 입력 파라미터
    - 클로저와 함수 모두 0개 이상의 입력 파라미터를 가질 수 있음
    - 이들 파라미터에 이름을 부여할 수 있습니다.
- 반환 값
    - 클로저와 함수 모두 반환 값을 지정할 수 있으며, 이 값은 어떠한 타입도 가능
- 코드 블록을 캡슐화
    - 클로저와 함수 모두 일련의 명령문을 그룹화하여 하나의 코드 블록

### 차이점

- 문맥 캡처
    - 클로저는 그들이 정의된 문맥에서 상수, 변수 등을 "캡처"할 수 있다는 점
    - 클로저가 그 값들을 나중에 사용하거나 참조할 때 유용
- 문법적 간결성
    - Swift에서 제공하는 여러 가지 문법적 축약 방식(예: 후행클로져, 타입 추론 등)으로 인해, 많은 경우에 훨씬 간결하게 작성될 수 있습니다.
- 이름과 선언 위치
    - 함수는 항상 이름을 가지며 코드의 최상위 레벨 또는 클래스/구조체 내부 등에서 선언됨
    - 반면에 클로저는 이름 없이 정의될 수 있으며, 변수나 상수를 초기화하는데 사용되거나 다른 함수의 인자로 전달
- 메모리 관리
    - 캡처된 값에 따라서 클로저와 함수의 메모리 관리 동작다름
- 호출 가능한 객체(Callable Objects)
    - Swift에서 함수와 메서드만 호출 가능한 객체
    - 반면에 클로저 자체는 호출 가능한 객체가 아니지만, 변수 또는 상수를 통해 호출될 수 있습니다.