## Extension이란?

'확장구문' 으로 번역될 수 있는 익스텐션(Extensions)은 이미 존재하는 클래스나 구조체, 열거형 등의 객체에 새로운 기능을 추가하여 확장해주는 구문

새로운 객체를 정의하는 것이 아니라 이미 존재하는 객체에 여러가지 요소를 추가해준다는 점이 특징이다.

하지만 자신의 독립적인 객체를 가지지 않고 다른 객체를 확장해준다는 특징 때문에 확장 구문은 단순히 구문이라고 보기도, 객체의 하나로 보기도 어렵다.

라이브러리나 프레임워크에 포함되어 소스 코드에 직접 접근 할 수 없는 객체라도 확장 (extension)을 이용하면 제약 없이 새로운 기능을 추가할 수 있다.

## Extension은 객체인가? 타입으로 사용되는가?

익스텐션은 extension이라는 키워드만 사용할 뿐 독립적인 객체를 생성하는 구문이 아니다.

→ 이미 정의 되어 있는 기존의 객체의 긴능을 더 추가해주는 것이다.

→ 따라서 객체가 아니고 타입으로 사용될 수 없다.

## [objc-c] Category vs [swift] extension

비슷한 점

- 기존 클래스 기능의 확장이 가능하다. → 기존 클래스의 코드를 수정하지 않고도 새로운 기능을 추가할 수 있다.
- 외부에서 사용 가능한 추가 메서드 및 속성을 추가할 수 있다. → 추가된 멤버는 해당 클래스의 인스턴스에서 사용할 수 있다.

차이점

- 카테고리는 자체적인 이름을 가지지만 익스텐션은 자체적인 이름을 갖지 않는다.
- 카테고리는 클래스에만 적용할 수 있지만 익스텐션은 클래스 뿐 아니라 구조체나 열거형 등의 객체에 대해서도 기능을 추가할 수 있다.
- 접근 제어
    - Swift의 extension은 extension이 정의된 파일 내에서는 private 멤버에 접근할 수 있다.
    - Objective-C의 category는 해당 클래스의 구현 파일 내부에서만 private 멤버에 접근할 수 있다.
- 메서드 오버라이딩
    - Swift의 extension을 사용하여 새로운 메서드를 추가할 때, 해당 메서드를 상속 클래스에서 오버라이딩할 수 있다.
    - Objective-C의 category에서는 새로운 메서드를 추가할 수는 있지만, 해당 메서드를 하위 클래스에서 오버라이딩하는 것은 불가능하다.
- 새로운 프로토콜 준수
    - Swift의 extension을 사용하여 클래스에 새로운 프로토콜을 준수하도록 만들 수 있다.
    - Objective-C의 category에서는 이러한 작업을 수행하기가 어렵다.

## Extension에서 구현할 수 있는 것

- 새로운 연산 프로퍼티 추가
    - 저장 프로퍼티를 추가할 수 없는 이유가 무엇인가?
        - **Designated Initializer (지정 이니셜라이저)**
            - 클래스의 주요 생성자로서, 클래스 내의 모든 프로퍼티를 초기화해야 합니다. Designated initializer는 클래스의 모든 상속된 프로퍼티 및 자체 프로퍼티를 초기화해야 합니다. 클래스마다 하나 이상의 Designated initializer를 가질 수 있습니다.
        - **Convenience Initializer (편의 이니셜라이저)**
            - Designated initializer를 보조하는 역할을 하는 생성자입니다. Convenience initializer는 초기화 프로세스 중에 Designated initializer를 호출해야 합니다. 즉, Convenience initializer는 클래스 내의 일부 프로퍼티만 초기화하고, Designated initializer를 호출하여 나머지 프로퍼티를 초기화합니다. Convenience initializer는 클래스를 좀 더 사용하기 쉽게 만들어줍니다.
        - **Deinitializer (소멸자)**
            - 클래스 인스턴스가 메모리에서 해제되기 전에 호출되는 블록입니다. 클래스에 deinitializer를 추가할 때, 인스턴스가 소멸되기 직전에 수행하고자 하는 정리 작업을 구현할 수 있습니다.
        
        이제 Swift의 extension을 사용할 때 왜 Designated initializer와 deinitializer를 추가할 수 없는지 설명하겠습니다.
        
        - **Designated initializer를 추가할 수 없는 이유:** Designated initializer는 클래스 내의 모든 프로퍼티를 초기화해야 하므로, extension 내에서는 해당 클래스의 저장 프로퍼티에 접근할 수 없습니다. extension은 해당 클래스의 저장 프로퍼티에 접근할 수 없으므로 모든 프로퍼티를 초기화할 수 없어 Designated initializer를 추가할 수 없습니다.
        - **deinitializer를 추가할 수 없는 이유:** deinitializer는 클래스의 인스턴스가 소멸되는 시점에 호출되는데, extension은 클래스를 확장하는 것이므로 extension 내에서 클래스의 인스턴스가 소멸되는 시점을 알 수 없습니다. 따라서 extension 내에서 deinitializer를 추가하는 것은 불가능합니다.
        
        Convenience initializer는 extension 내에서 추가할 수 있습니다. extension을 사용하여 클래스의 특정 사용 사례에 대한 초기화를 간소화하고자 할 때 Convenience initializer를 추가할 수 있습니다.
        
        간단히 말하면, Designated initializer와 deinitializer는 클래스 정의 내에서만 정의할 수 있으며, extension은 해당 클래스의 초기화 및 소멸에 영향을 미치지 않습니다. Convenience initializer는 extension 내에서 추가할 수 있지만, 이러한 initializer에서도 Designated initializer를 호출해야 합니다.
        
- 새로운 메서드 정의
- 새로운 초기화 구문 추가
- 네 기존 객체를 수정하지 않고 프로토콜을 구현할 수 있음.

## Extension 내부에서 함수를 override 할 수 있는가?
Objective-C와의 호환성을 위해 Extension에서 Override를 허용하기 때문이다.

즉, 메서드가 Objective-C와 호환되는 경우에만 확장에서 메소드 Override 할 수 있다.

## Swift에서 extension 내에서 override를 사용하는 것은 일반적으로 지양되는 것이 좋다.

- **가독성과 예측 가능성**
    - 코드의 가독성을 유지하고 다른 개발자들이 코드를 이해하기 쉽게 만들려면 클래스 또는 구조체의 동작을 변경하는 부분이 확장이나 서브클래싱으로 명시적으로 표현되어야 한다.
    - extension에서 override를 사용하면 코드의 동작이 의도치 않게 바뀔 수 있고, 이로 인해 예기치 않은 버그가 발생할 가능성이 있다.
- **불안정성**
    - extension은 해당 타입을 확장하거나 보완하는 데 사용된다. 기본 클래스나 구조체 정의 내에서 override하는 것은 해당 타입의 핵심 동작을 변경하려는 시도로 이해된다.
    - extension은 해당 타입의 기능을 확장하거나 부가적인 기능을 추가하는 데 사용되어야 한다.
- **유지 관리의 어려움**
    - extension 내에서 override를 사용하면 클래스의 메서드 또는 프로퍼티가 여러 곳에서 변경될 수 있으므로 코드의 유지 관리가 더 어려워진다.
    - 클래스 정의 내에서 override를 사용하면 변경이 한 곳에서만 이루어지므로 유지 보수가 훨씬 간단하다.
- **확장의 목적 교란**
    - extension은 주로 기존 코드에 새로운 기능을 추가하거나 프로토콜을 준수하도록 타입을 확장하는 데 사용된다.
    - override를 사용하면 해당 목적이 흐려질 수 있다.

따라서 extension을 사용하여 타입을 확장하고, 필요한 경우 기존 클래스나 구조체의 동작을 변경하려면 해당 클래스나 구조체의 정의 내에서 override 키워드를 사용하는 것이 바람직하다. 

이렇게 하면 코드의 가독성과 예측 가능성이 향상되며, 유지 보수가 더 쉬워집니다. 

Extension은 기능을 추가하거나 코드를 분리하는 데 유용하지만, 동작을 변경하기 위한 목적으로 사용하는 것은 지양해야 한다.

## Closure에 대하여 설명하시오.

일정 기능을 수행하는 코드의 블럭을 뜻하며 일급 객체의 역할을 할 수 있다.

- Named Closure : 이름이 있는 클로저로 일반적인 함수
- Unnamed Closure : 이름이 없는 **익명 함수**로 일반적으로 클로저를 지칭함.

Swift에서 함수는 일급 객체이므로 클로저(익명 함수) 또한 일급 객체로서의 역할이 가능하다.

## 입력 매개변수와 반환값을 가질 수 있나?

클로저는 입력 매개변수와 반환값을 가질 수 있다. 

매개변수와 반환값은 클로저의 타입을 정의하는 데 사용된다. 매개변수와 반환값은 생략 가능하며, 클로저가 어떤 작업을 수행하는지에 따라 다양하게 사용된다.

## 클로저는 어디서 사용되나?

- **함수를 인자로 받는 함수나 메서드 (고차 함수)**
    - 클로저를 사용하여 정렬, 필터링, 매핑 등의 작업을 수행하는 함수를 작성할 수 있다.
- **비동기 작업 처리 (Completion Handlers)**
    - 비동기 작업이 완료되면 클로저를 호출하여 결과를 처리한다.
- **객체의 프로퍼티나 메서드에 대한 콜백 함수**
    - 객체의 상태 변화에 따라 클로저를 호출하여 특정 작업을 수행한다.
- **싱글톤 패턴 및 지연 초기화**
    - 클로저를 사용하여 객체를 처음으로 초기화하거나 필요한 시점에 초기화한다.

## Closure와 함수와의 관계에 대해 설명하시오.
- 클로저는 사실상 익명 함수로 생각할 수 있음.
    - 클로저는 이름 없이 정의되는 함수이다. 함수와 마찬가지로 입력을 받고 출력을 반환할 수 있으며, 실행 가능한 코드 블록이다. 다만, 함수와는 달리 이름이 없기 때문에 클로저는 주로 변수나 상수에 할당되거나 다른 함수의 인자로 전달되는 등의 상황에서 사용된다.
- 함수는 클로저의 일종임.
    - 함수는 클로저의 특별한 형태이다. Swift에서 함수는 클로저의 일종으로 정의되어 있으며, 함수는 이름이 있는 클로저이다. 따라서 함수는 클로저의 확장된 개념으로 볼 수 있다.

## **함수와 클로저의 공통점**

- 함수와 클로저 모두 입력(파라미터)을 받을 수 있다.
- 함수와 클로저 모두 출력(반환 값)을 가질 수 있다.
- 함수와 클로저 모두 실행 가능한 코드 블록이다.
- 함수와 클로저 모두 변수, 상수, 속성 등에 할당될 수 있다.
- 함수와 클로저 모두 다른 함수 또는 메서드의 인자로 전달할 수 있다.
- 함수와 클로저 모두 클로저 캡처(closure capture)를 사용하여 외부 변수나 상수를 참조할 수 있다.

## Swift의 클로저는 다양한 형태를 가질 수 있다.

일반적인 함수처럼 이름을 가진 클로저부터, 간결한 형태의 클로저(트레일링 클로저, 간단한 클로저 표현식)까지 다양한 방법으로 정의할 수 있다.

```swift
// 함수 정의
func add(x: Int, y: Int) -> Int {
    return x + y
}

// 함수 호출
let result1 = add(x: 5, y: 3)

// 클로저 정의
let addClosure: (Int, Int) -> Int = { (x, y) in
    return x + y
}

// 클로저 호출
let result2 = addClosure(5, 3)
```

위의 코드에서 `add` 함수와 `addClosure` 클로저는 동일한 작업을 수행한다.

차이점은 함수는 이름을 가지고 있고 클로저는 이름이 없다. 

함수와 클로저는 모두 `Int` 타입의 두 정수를 더하고 결과를 반환하는 역할을 한다.

따라서 Swift에서 함수와 클로저는 서로 유사하며, 클로저는 함수와 마찬가지로 강력한 기능을 제공하는 프로그래밍 요소 중 하나이다.